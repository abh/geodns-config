#!/usr/bin/env perl
use Mojolicious::Lite;
use v5.12.0;
use Data::Dump qw(pp);
use lib 'lib';
use DnsConfig;
use GeoConfig;
use GeoDNS::Log;

app->log(GeoDNS::Log->singleton);

plugin 'Config' => {default => {monitors => [], secret => ''}};

if (app->config->{secret}) {
    app->secret(app->config->{secret});
}

my %monitors;

my $loader = Mojo::Loader->new;
for my $module (@{$loader->search('GeoDNS::Monitor')}) {

    my $monitor = $module;
    $monitor =~ s/^GeoDNS::Monitor:://;

    next unless grep { lc $monitor eq lc $_ } @{app->config->{monitors}};

    app->log->info("Loading monitor $monitor");

    my $e = $loader->load($module);
    warn qq{Loading "$module" failed: $e} and next if ref $e;

    my %args = %{app->config->{lc $monitor}};
    $monitors{lc $monitor} = $module->new(%args, mojo => app);

}

my $nodes;
{
    die "'nodes' configuration required" unless app->config->{nodes};
    my ($type) = keys %{ app->config->{nodes} };
    my $node_module = "GeoDNS::Nodes::$type";
    my $e = $loader->load($node_module);
    warn qq{Loading "$node_module" failed: $e} if ref $e;
    $nodes = $node_module->new( %{ app->config->{nodes}->{$type} } );
}

my $config = GeoConfig->new(
    'config_path' => 'config',
    nodes         => $nodes,
    domain_name   => app->config->{domain_name}
);
my $dns = $config->dns;

app->log->info("App starting");

my $log_buffer_dirty = 0;
my @log_buffer;
app->log->on(
    message => sub {
        my ($log, $level, @lines) = @_;
        push @log_buffer, scalar gmtime() . " [$level] " . join "\n", @lines;
        $log_buffer_dirty++;
    }
);

for my $monitor (keys %monitors) {
    app->log->warn("Starting $monitor monitor");
    $monitors{$monitor}->start();
}

my $i = 0;
Mojo::IOLoop->recurring(
    2 => sub {
        $i++;

        #app->log->debug("i: $i");
        $config->refresh;
        if ($config->dirty) {
            if (!$config->ready) {
                app->log->warn("Data not ready: ". join ", ", $config->not_ready);
                return;
            }
            app->log->info("Data updated, reloading");
            $dns->setup_data;

            #say "DNS: ", pp($dns->dns);
            app->log->info("Updating DNS data file");
            $dns->write_dns("dns/g.develooper.org.json");
        }
    }
);

Mojo::IOLoop->singleton->reactor->on(
    error => sub {
        my ($reactor, $err) = @_;
        app->log->error($err);
    }
);

get '/' => sub {
    my $self = shift;
    $self->stash(config => $config);

    #$self->app->log->warn("PATHS: " . join(", ", @{ $self->app->renderer->paths }));
    $self->render('index');
};

get '/log' => sub {
    my $self = shift;
    $self->stash(log_buffer => \@log_buffer);
    $self->render('log');
};

get '/api/nodes' => sub {
    my $self = shift;
    my $nodes = $config->nodes->all;
    my $ips  = $monitors{panopta}->ips;
    my @nodes = map {
        my $ip = $nodes->{$_};
        {   name     => $_,
            ip       => $ip,
            monitors => ($ips->{$ip} || [])
        }
    } sort keys %$nodes;
    $self->render(json => \@nodes);
};

get '/api/groups' => sub {
    my $self   = shift;
    my $groups = $config->groups;
    my @groups = map { {name => $_, pops => $groups->{$_}} } sort keys %$groups;
    $self->render(json => \@groups);
};

get '/api/labels' => sub {
    my $self   = shift;
    my $labels = $config->labels;
    my @labels = map { {name => $_, config => $labels->{$_}} } sort keys %$labels;
    $self->render(json => \@labels);
};

get '/api/monitor' => sub {
    my $self = shift;
    $self->render(json => {monitor => [sort keys %monitors]});
};

get '/api/monitor/:monitor/status' => sub {
    my $self         = shift;
    my $monitor_name = $self->stash('monitor');
    my $monitor      = $monitors{$monitor_name};
    unless ($monitor) {
        app->log->warn("Unknown monitor name :monitor $monitor_name");
        $self->render(json => {});
    }
    $self->render(json => {outages => $monitor->outages});
};

get '/api/monitor/:monitor/servers' => sub {
    my $self         = shift;
    my $monitor_name = $self->stash('monitor');
    my $monitor      = $monitors{$monitor_name};
    unless ($monitor) {
        app->log->warn("Unknown monitor name :monitor $monitor_name");
        $self->render(json => {});
    }

    #$self->render(json => { servers => $monitor->ips });
    $self->render(json => $monitor->servers);
};

get '/api/events' => sub {
    my $self = shift;

    # Increase inactivity timeout for connection a bit
    Mojo::IOLoop->stream($self->tx->connection)->timeout(300);

    # Change content type
    $self->res->headers->content_type('text/event-stream');

    # make sure Mojo knows it doesn't have to render a page
    $self->write("event: start\ndata: 1\n\n");

    my $json = Mojo::JSON->new;

    # Subscribe to "message" event and forward "log" events to browser
    my $cb = $self->app->log->on(
        message => sub {
            my ($log, $level, @lines) = @_;
            my $data = $json->encode({level => $level, lines => join("\n", @lines)});

            #say "DATA[$data]";
            #say "LEVEL: $level";
            #say "LINES: ", @lines;
            $self->write("event:log\ndata: $data\n\n");
        }
    );

    # Unsubscribe from "message" event again once we are done
    $self->on(
        finish => sub {
            my $self = shift;
            $self->app->log->unsubscribe(message => $cb);
        }
    );
};


app->start;

__DATA__

@@ index.html.ep
% layout 'default';
% title 'Welcome';

<div ng-app="geodns">
    <div ng-view></div>
</div>

@@ log.html.ep
% layout 'default';
% title 'GeoDNS Config Log';

<div id="events">
<% for my $data (reverse @$log_buffer) { %>
    <%= $data %><br>
<% } %>
</div>
