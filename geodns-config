#!/usr/bin/env perl
use Mojolicious::Lite;
use v5.12.0;
use Data::Dump qw(pp);
use lib 'lib';
use DnsConfig;
use GeoConfig;
use GeoDNS::Log;

app->log(GeoDNS::Log->singleton);

plugin 'Config' => {default => {monitors => [], secret => ''}};

if (app->config->{monitors}) {
    for my $monitor (@{app->config->{monitors}}) {
        my ($name) = keys %$monitor;
        $monitor = $monitor->{$name};
        $monitor->{name} = $name;
    }
}

if (app->config->{secret}) {
    app->secret(app->config->{secret});
}

my $domain_name = app->config->{domain_name}
  or die "domain_name configuration required\n";

my $loader = Mojo::Loader->new;

my %config;
for my $type (qw(Nodes Labels)) {
    my $lc_type = lc $type;
    app->config->{$lc_type} or next;
    my ($module)    = keys %{app->config->{nodes}};
    my $module_name = "GeoDNS::${type}::${module}";
    my $e           = $loader->load($module_name);
    warn qq{Loading "$module_name" failed: $e} if ref $e;
    $config{$lc_type} = $module_name->new(%{app->config->{nodes}->{$module}});
    if ($config{$lc_type}->can('ua')) {
        $config{$lc_type}->ua(app->ua);
    }
}

my $config = GeoConfig->new(
    %config,
    'config_path' => 'config',
    domain_name   => app->config->{domain_name}
);

my %monitors;

for my $module (@{$loader->search('GeoDNS::Monitor')}) {

    my $monitor = $module;
    $monitor =~ s/^GeoDNS::Monitor:://;

    my ($module_config) = grep { lc $monitor eq lc $_->{name} } @{app->config->{monitors}};
    next unless $module_config;

    app->log->info("Loading monitor $monitor");

    my $e = $loader->load($module);
    warn qq{Loading "$module" failed: $e} and next if ref $e;

    my %args = %$module_config;
    delete $args{name};
    $monitors{lc $monitor} = $module->new(%args, mojo => app, config => $config);
}

my $dns = $config->dns;

app->log->info("App starting");

my $log_buffer_dirty = 0;
my @log_buffer;
app->log->on(
    message => sub {
        my ($log, $level, @lines) = @_;
        push @log_buffer, scalar gmtime() . " [$level] " . join "\n", @lines;
        $log_buffer_dirty++;
    }
);

for my $monitor (keys %monitors) {
    Mojo::IOLoop->timer(
        1 => sub {
            app->log->warn("Starting $monitor monitor");
            $monitors{$monitor}->start();
        }
    );
}

my $i = 0;
Mojo::IOLoop->recurring(
    3 => sub {
        $i++;

        #app->log->debug("i: $i");
        $config->refresh;

        if (%monitors and (grep { !$_->ready } values %monitors)) {
            app->log->warn("Monitor not ready");
            return;
        }

        if ($config->dirty) {
            if (!$config->ready) {
                app->log->warn("Data not ready: " . join ", ", $config->not_ready);
                return;
            }
            app->log->info("Data updated, reloading");
            $dns->setup_data;

            #say "DNS: ", pp($dns->dns);
            app->log->info("Updating DNS data file");
            $dns->write_dns("dns/${domain_name}.json");
        }
    }
);

Mojo::IOLoop->singleton->reactor->on(
    error => sub {
        my ($reactor, $err) = @_;
        app->log->error($err);
    }
);

get '/' => sub {
    my $self = shift;
    $self->stash(config => $config);

    #$self->app->log->warn("PATHS: " . join(", ", @{ $self->app->renderer->paths }));
    $self->render('index');
};

get '/log' => sub {
    my $self = shift;
    $self->stash(log_buffer => \@log_buffer);
    $self->render('log');
};

get '/api/nodes' => sub {
    my $self  = shift;
    my $nodes = $config->nodes->all;
    # warn "ALL: ", pp($nodes);

    my @nodes = map {
        my $d = $nodes->{$_};
        {   name     => $d->name,
            ip       => $d->ip,
            active   => $d->active,
            monitors => (
                [   map {
                        {
                            %{$monitors{$_}->status($d->name)},
                              name => $_,
                        }
                    } sort keys %monitors
                ]
            ),
        }
    } sort keys %$nodes;
    $self->render(json => \@nodes);
};

get '/api/groups' => sub {
    my $self   = shift;
    my $groups = $config->groups;
    my @groups = map { {name => $_, pops => $groups->{$_}} } sort keys %$groups;
    $self->render(json => \@groups);
};

get '/api/labels' => sub {
    my $self   = shift;
    my $labels = $config->labels->all;
    my @labels = map { {name => $_, config => $labels->{$_}} } sort keys %$labels;
    $self->render(json => \@labels);
};

get '/api/monitor' => sub {
    my $self = shift;
    $self->render(json => {monitor => [sort keys %monitors]});
};

get '/api/monitor/:monitor/status' => sub {
    my $self         = shift;
    my $monitor_name = $self->stash('monitor');
    my $monitor      = $monitors{$monitor_name};
    unless ($monitor) {
        app->log->warn("Unknown monitor name :monitor $monitor_name");
        $self->render(json => {});
    }
    $self->render(json => {checks => $monitor->checks});
};

get '/api/monitor/:monitor/servers' => sub {
    my $self         = shift;
    my $monitor_name = $self->stash('monitor');
    my $monitor      = $monitors{$monitor_name};
    unless ($monitor) {
        app->log->warn("Unknown monitor name :monitor $monitor_name");
        $self->render(json => {});
    }

    #$self->render(json => { servers => $monitor->ips });
    $self->render(json => $monitor->servers);
};

get '/api/events' => sub {
    my $self = shift;

    # Increase inactivity timeout for connection a bit
    Mojo::IOLoop->stream($self->tx->connection)->timeout(300);

    # Change content type
    $self->res->headers->content_type('text/event-stream');

    # make sure Mojo knows it doesn't have to render a page
    $self->write("event: start\ndata: 1\n\n");

    my $json = Mojo::JSON->new;

    # Subscribe to "message" event and forward "log" events to browser
    my $cb = $self->app->log->on(
        message => sub {
            my ($log, $level, @lines) = @_;
            my $data = $json->encode({level => $level, lines => join("\n", @lines)});

            #say "DATA[$data]";
            #say "LEVEL: $level";
            #say "LINES: ", @lines;
            $self->write("event:log\ndata: $data\n\n");
        }
    );

    # Unsubscribe from "message" event again once we are done
    $self->on(
        finish => sub {
            my $self = shift;
            $self->app->log->unsubscribe(message => $cb);
        }
    );
};


app->start;

__DATA__

@@ index.html.ep
% layout 'default';
% title 'Welcome';

<div ng-app="geodns">
    <div ng-view></div>
</div>

@@ log.html.ep
% layout 'default';
% title 'GeoDNS Config Log';

<div id="events">
<% for my $data (reverse @$log_buffer) { %>
    <%= $data %><br>
<% } %>
</div>
